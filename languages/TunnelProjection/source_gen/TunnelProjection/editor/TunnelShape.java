package TunnelProjection.editor;

/*Generated by MPS */

import de.itemis.mps.editor.diagram.runtime.shape.AbstractShape;
import java.util.List;
import org.jetbrains.mps.openapi.model.SNode;
import java.awt.Graphics2D;
import java.awt.geom.Rectangle2D;
import de.itemis.mps.editor.diagram.runtime.shape.IShapeStyle;
import java.awt.Color;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import org.jetbrains.mps.openapi.language.SProperty;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

public class TunnelShape extends AbstractShape {

  private int numberOfTunnelHoles;
  private List<SNode> holes;

  public TunnelShape(int numberOfTunnelHoles, List<SNode> holes) {
    this.numberOfTunnelHoles = numberOfTunnelHoles;
    this.holes = holes;
  }



  @Override
  protected void drawShadow(final Graphics2D graphics, final Rectangle2D bounds, IShapeStyle style) {
  }

  @Override
  protected void draw(final Graphics2D graphics, final Rectangle2D bounds, IShapeStyle style) {

    graphics.setColor(Color.LIGHT_GRAY);
    graphics.fillRect((int) bounds.getMinX(), (int) bounds.getMinY(), (int) bounds.getWidth(), (int) bounds.getHeight());

    int leftPointX = (int) bounds.getMinX();
    int leftPointY = (int) (bounds.getMaxY() + ((bounds.getMinY() - bounds.getMaxY()) / 2));
    int rightPointX = (int) bounds.getMaxX();
    int rightPointY = leftPointY;

    int equalLanesDivision = 0;

    graphics.setColor(Color.MAGENTA);

    if (this.numberOfTunnelHoles == 0 || this.numberOfTunnelHoles == 1) {
      // do nothing 
    } else if (this.numberOfTunnelHoles == 2) {
      graphics.drawLine(leftPointX, leftPointY, rightPointX, rightPointY);
      // Display hole names as part of the tunnel 
      if (isEmptyString(SPropertyOperations.getString(ListSequence.fromList(this.holes).getElement(0), PROPS.name$tAp1))) {
        graphics.drawString("no name", leftPointX + ((int) bounds.getWidth()) / 2, leftPointY + 10);
      } else {
        graphics.drawString(SPropertyOperations.getString(ListSequence.fromList(this.holes).getElement(0), PROPS.name$tAp1), leftPointX + ((int) bounds.getWidth()) / 2, leftPointY + 10);
      }
      if (isEmptyString(SPropertyOperations.getString(ListSequence.fromList(this.holes).getElement(1), PROPS.name$tAp1))) {
        graphics.drawString("no name", leftPointX + ((int) bounds.getWidth()) / 2, leftPointY - 5);
      } else {
        graphics.drawString(SPropertyOperations.getString(ListSequence.fromList(this.holes).getElement(1), PROPS.name$tAp1), leftPointX + ((int) bounds.getWidth()) / 2, leftPointY - 5);
      }
    } else {
      equalLanesDivision = ((int) bounds.getHeight()) / this.numberOfTunnelHoles;
      for (int i = 0; i < this.numberOfTunnelHoles - 1; i++) {
        graphics.drawLine(leftPointX, ((int) bounds.getMinY()) + equalLanesDivision * (i + 1), rightPointX, ((int) bounds.getMinY()) + equalLanesDivision * (i + 1));

        // Avoiding null pointer exception for just created tunnel holes (no names initially) 
        if (isEmptyString(SPropertyOperations.getString(ListSequence.fromList(this.holes).getElement(i), PROPS.name$tAp1))) {
          graphics.drawString("no name", leftPointX + ((int) bounds.getWidth()) / 2, ((int) bounds.getMinY()) + equalLanesDivision * (i + 1) - 5);
        } else {
          graphics.drawString(SPropertyOperations.getString(ListSequence.fromList(this.holes).getElement(i), PROPS.name$tAp1), leftPointX + ((int) bounds.getWidth()) / 2, ((int) bounds.getMinY()) + equalLanesDivision * (i + 1) - 5);
        }

        if (isEmptyString(SPropertyOperations.getString(ListSequence.fromList(this.holes).getElement(i + 1), PROPS.name$tAp1))) {
          graphics.drawString("no name", leftPointX + ((int) bounds.getWidth()) / 2, ((int) bounds.getMinY()) + equalLanesDivision * (i + 1) + 12);
        } else {
          graphics.drawString(SPropertyOperations.getString(ListSequence.fromList(this.holes).getElement(i + 1), PROPS.name$tAp1), leftPointX + ((int) bounds.getWidth()) / 2, ((int) bounds.getMinY()) + equalLanesDivision * (i + 1) + 12);
        }
      }


    }



  }

  private static boolean isEmptyString(String str) {
    return str == null || str.length() == 0;
  }

  private static final class PROPS {
    /*package*/ static final SProperty name$tAp1 = MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name");
  }
}
