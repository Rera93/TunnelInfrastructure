package TunnelProjection.editor;

/*Generated by MPS */

import de.itemis.mps.editor.diagram.runtime.shape.AbstractShape;
import org.jetbrains.mps.openapi.language.SEnumerationLiteral;
import org.jetbrains.mps.openapi.model.SNode;
import java.awt.Graphics2D;
import java.awt.geom.Rectangle2D;
import de.itemis.mps.editor.diagram.runtime.shape.IShapeStyle;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SEnumOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import java.awt.Color;
import java.awt.Stroke;
import java.awt.BasicStroke;

public class Road extends AbstractShape {

  private SEnumerationLiteral type;
  private boolean isTunnelRoad;
  private int lanes;
  private SNode semaphore;
  private SEnumerationLiteral light;
  private SNode beam;
  private boolean isBeamClosed;

  public Road(SEnumerationLiteral type, boolean isTunnelRoad, int lanes, SNode semaphore, SEnumerationLiteral light, SNode beam, boolean isBeamClosed) {
    this.type = type;
    this.isTunnelRoad = isTunnelRoad;
    this.lanes = lanes;
    this.semaphore = semaphore;
    this.light = light;
    this.beam = beam;
    this.isBeamClosed = isBeamClosed;
  }



  @Override
  protected void drawShadow(final Graphics2D graphics, final Rectangle2D bounds, IShapeStyle style) {
    // Filling road rectangle with the corresponding color depending on the road type. 
    if (this.type.equals(SEnumOperations.getMember(MetaAdapterFactory.getEnumeration(0x72c81d76425049a4L, 0x8dfa274e9e7a2b19L, 0x1269a468049550c0L, "TunnelProjection.structure.RoadType"), 0x1269a468049550c1L, "Bicycle"))) {
      graphics.setColor(new Color(108, 76, 81));
    } else if (this.type.equals(SEnumOperations.getMember(MetaAdapterFactory.getEnumeration(0x72c81d76425049a4L, 0x8dfa274e9e7a2b19L, 0x1269a468049550c0L, "TunnelProjection.structure.RoadType"), 0x1269a468049550c5L, "Car"))) {
      graphics.setColor(new Color(102, 102, 102));
    } else if (this.type.equals(SEnumOperations.getMember(MetaAdapterFactory.getEnumeration(0x72c81d76425049a4L, 0x8dfa274e9e7a2b19L, 0x1269a468049550c0L, "TunnelProjection.structure.RoadType"), 0x1269a468049550c9L, "Highway"))) {
      graphics.setColor(new Color(247, 212, 111));
    } else if (this.type.equals(SEnumOperations.getMember(MetaAdapterFactory.getEnumeration(0x72c81d76425049a4L, 0x8dfa274e9e7a2b19L, 0x1269a468049550c0L, "TunnelProjection.structure.RoadType"), 0x1269a468049550c2L, "Emergency"))) {
      graphics.setColor(new Color(1, 156, 65));
    } else {
      graphics.setColor(Color.RED);
    }
    graphics.fillRect((int) bounds.getMinX() - 3, (int) bounds.getMinY() - 3, (int) bounds.getWidth(), (int) bounds.getHeight());
  }

  @Override
  protected void draw(final Graphics2D graphics, final Rectangle2D bounds, IShapeStyle style) {

    graphics.setColor(Color.WHITE);


    int leftPointX = (int) bounds.getMinX();
    int leftPointY = (int) (bounds.getMaxY() + ((bounds.getMinY() - bounds.getMaxY()) / 2));
    int rightPointX = (int) bounds.getMaxX();
    int rightPointY = leftPointY;


    // Differentiate between outer roads and inner tunnel roads. Tunnel roads are outlined with magenta while outer roads are not. 
    if (this.isTunnelRoad) {
      graphics.setColor(Color.MAGENTA);
      graphics.drawRect((int) (bounds.getX()), (int) (bounds.getY()), (int) (bounds.getWidth()), (int) (bounds.getHeight()));
    }

    // Creation of dashed lines 

    Stroke dashed = new BasicStroke(3, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0, new float[]{9}, 0);
    graphics.setStroke(dashed);
    graphics.setColor(Color.WHITE);
    int equalLanesDivision = 0;

    //  Depending on the number of lanes ==> The roads will be re-drawn with the corresponding number of dashed lines. 
    if (this.lanes == 1) {
      // do nothing 
    } else if (this.lanes == 2) {
      graphics.drawLine(leftPointX, leftPointY, rightPointX, rightPointY);
    } else if (this.lanes == 3) {
      equalLanesDivision = ((int) bounds.getHeight()) / 3;
      graphics.drawLine(leftPointX, ((int) bounds.getMinY()) + equalLanesDivision, rightPointX, ((int) bounds.getMinY()) + equalLanesDivision);
      graphics.drawLine(leftPointX, ((int) bounds.getMinY()) + equalLanesDivision * 2, rightPointX, ((int) bounds.getMinY()) + equalLanesDivision * 2);
    } else if (this.lanes == 4) {
      equalLanesDivision = ((int) bounds.getHeight()) / 4;
      graphics.drawLine(leftPointX, ((int) bounds.getMinY()) + equalLanesDivision, rightPointX, ((int) bounds.getMinY()) + equalLanesDivision);
      graphics.drawLine(leftPointX, ((int) bounds.getMinY()) + equalLanesDivision * 2, rightPointX, ((int) bounds.getMinY()) + equalLanesDivision * 2);
      graphics.drawLine(leftPointX, ((int) bounds.getMinY()) + equalLanesDivision * 3, rightPointX, ((int) bounds.getMinY()) + equalLanesDivision * 3);
    } else if (this.lanes == 5) {
      equalLanesDivision = ((int) bounds.getHeight()) / 5;
      graphics.drawLine(leftPointX, ((int) bounds.getMinY()) + equalLanesDivision, rightPointX, ((int) bounds.getMinY()) + equalLanesDivision);
      graphics.drawLine(leftPointX, ((int) bounds.getMinY()) + equalLanesDivision * 2, rightPointX, ((int) bounds.getMinY()) + equalLanesDivision * 2);
      graphics.drawLine(leftPointX, ((int) bounds.getMinY()) + equalLanesDivision * 3, rightPointX, ((int) bounds.getMinY()) + equalLanesDivision * 3);
      graphics.drawLine(leftPointX, ((int) bounds.getMinY()) + equalLanesDivision * 4, rightPointX, ((int) bounds.getMinY()) + equalLanesDivision * 4);

    }

    // Semaphore creation if available in Road or Tunnel Road  
    if ((this.semaphore != null)) {
      graphics.setColor(Color.BLACK);
      graphics.fillRect((int) bounds.getX() + 10, (int) bounds.getY(), 35, (int) bounds.getHeight());
      graphics.setStroke(new BasicStroke());
      graphics.setColor(Color.RED);
      if (this.light.equals(SEnumOperations.getMember(MetaAdapterFactory.getEnumeration(0x72c81d76425049a4L, 0x8dfa274e9e7a2b19L, 0x261858895ffc2fe6L, "TunnelProjection.structure.SemaphoreLights"), 0x261858895ffc2febL, "Red"))) {
        graphics.fillOval((int) bounds.getX() + 15, (int) bounds.getY() + 5, 25, (int) bounds.getHeight() / 3 - 5);
      } else {
        graphics.drawOval((int) bounds.getX() + 15, (int) bounds.getY() + 5, 25, (int) bounds.getHeight() / 3 - 5);
      }
      graphics.setColor(Color.ORANGE);
      if (this.light.equals(SEnumOperations.getMember(MetaAdapterFactory.getEnumeration(0x72c81d76425049a4L, 0x8dfa274e9e7a2b19L, 0x261858895ffc2fe6L, "TunnelProjection.structure.SemaphoreLights"), 0x261858895ffc2fe8L, "Orange"))) {
        graphics.fillOval((int) bounds.getX() + 15, (int) bounds.getY() + (int) bounds.getHeight() / 3 + 5, 25, (int) bounds.getHeight() / 3 - 5);
      } else {
        graphics.drawOval((int) bounds.getX() + 15, (int) bounds.getY() + (int) bounds.getHeight() / 3 + 5, 25, (int) bounds.getHeight() / 3 - 5);
      }
      graphics.setColor(Color.GREEN);
      if (this.light.equals(SEnumOperations.getMember(MetaAdapterFactory.getEnumeration(0x72c81d76425049a4L, 0x8dfa274e9e7a2b19L, 0x261858895ffc2fe6L, "TunnelProjection.structure.SemaphoreLights"), 0x261858895ffc2fe7L, "Green"))) {
        graphics.fillOval((int) bounds.getX() + 15, (int) bounds.getY() + (int) bounds.getHeight() / 3 * 2 + 5, 25, (int) bounds.getHeight() / 3 - 5);
      } else {
        graphics.drawOval((int) bounds.getX() + 15, (int) bounds.getY() + (int) bounds.getHeight() / 3 * 2 + 5, 25, (int) bounds.getHeight() / 3 - 5);
      }

    }

    // Beam creation if available 
    if ((this.beam != null)) {
      // If beam is closed, a red-white vertical stripe is drawn on the road 
      if (this.isBeamClosed) {
        graphics.setStroke(new BasicStroke(3));
        graphics.setColor(Color.WHITE);
        graphics.drawLine((int) (bounds.getX() + bounds.getWidth() - 20), (int) bounds.getY(), (int) (bounds.getX() + bounds.getWidth() - 20), (int) (bounds.getY() + bounds.getHeight()));

        graphics.setStroke(new BasicStroke(3, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0, new float[]{9}, 0));
        graphics.setColor(Color.RED);
        graphics.drawLine((int) (bounds.getX() + bounds.getWidth() - 20), (int) bounds.getY(), (int) (bounds.getX() + bounds.getWidth() - 20), (int) (bounds.getY() + bounds.getHeight()));
      } else {
        graphics.setStroke(new BasicStroke(3));
        graphics.setColor(Color.WHITE);
        graphics.drawLine((int) (bounds.getX() + bounds.getWidth()), (int) bounds.getY(), (int) (bounds.getX() + bounds.getWidth() - 20), (int) (bounds.getY() + bounds.getHeight()));

        graphics.setStroke(new BasicStroke(3, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0, new float[]{9}, 0));
        graphics.setColor(Color.RED);
        graphics.drawLine((int) (bounds.getX() + bounds.getWidth()), (int) bounds.getY(), (int) (bounds.getX() + bounds.getWidth() - 20), (int) (bounds.getY() + bounds.getHeight()));
      }
    }



  }

}
